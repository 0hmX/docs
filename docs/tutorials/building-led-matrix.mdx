---
title: Building a 3x5 LED Matrix
---

## Overview

This tutorial will walk you through building a 3x5 LED matrix controlled by a Raspberry Pi Pico using tscircuit.

import TscircuitIframe from "@site/src/components/TscircuitIframe"

<TscircuitIframe defaultView="3d" code={`
import { WS2812B_2020 as LedWithIc } from "@tsci/seveibar.WS2812B_2020"
import { usePICO_W } from "@tsci/seveibar.PICO_W"

type Point = { x: number; y: number }

type GridCellPositions = {
  index: number
  center: Point
  topLeft: Point
  bottomRight: Point
}

type GridOptions = {
  rows: number
  cols: number
  xSpacing?: number
  ySpacing?: number
  width?: number
  height?: number
  offsetX?: number
  offsetY?: number
  yDirection?: "cartesian" | "up-is-negative"
}

// ToDO import from tscircuit utils in the future
function grid({
  rows,
  cols,
  xSpacing,
  ySpacing,
  width,
  height,
  offsetX = 0,
  offsetY = 0,
  yDirection = "cartesian",
}: GridOptions): GridCellPositions[] {
  // Calculate cell dimensions
  const cellWidth = width ? width / cols : xSpacing ?? 1
  const cellHeight = height ? height / rows : ySpacing ?? 1

  const cells: GridCellPositions[] = []

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const index = row * cols + col

      // Calculate center position
      const centerX = offsetX + col * cellWidth + cellWidth / 2
      const rawCenterY = offsetY + row * cellHeight + cellHeight / 2

      // Adjust Y coordinate based on yDirection
      const centerY =
        yDirection === "cartesian"
          ? offsetY + (rows - 1 - row) * cellHeight + cellHeight / 2
          : rawCenterY

      cells.push({
        index,
        center: { x: centerX, y: centerY },
        topLeft: {
          x: centerX - cellWidth / 2,
          y: centerY + cellHeight / 2,
        },
        bottomRight: {
          x: centerX + cellWidth / 2,
          y: centerY - cellHeight / 2,
        },
      })
    }
  }

  return cells
}


export default () => {
  const U1 = usePICO_W("U1")
  return (
    <board
      width="55mm"
      height="52mm"
      autorouter="auto-cloud"
    >
      <U1 pcbRotation="90deg" pcbX={-15} pcbY={0} />
      {grid({ cols: 3, rows: 5, xSpacing: 8, ySpacing: 5, offsetX: 3 }).map(
        ({ center, index }) => {
          const ledName = "LED" + (index + 1)
          const prevLedName = index > 0 ? "LED" + index : null
          return (
            <>
              <LedWithIc schX={center.x/2} schY={5 + center.y/2} name={ledName} pcbX={center.x} pcbY={center.y} />
              <trace from={("." + ledName + " .GND")} to="net.GND" />
              <trace from={("." + ledName + " .VDD")} to="net.V5" />
              {prevLedName && <trace from={("." + prevLedName + " .DO")} to={("." + ledName + " .DI")} />}
            </>
          )
        }
      )}

      <trace from=".LED1 .DI" to={U1.GP6_SPI0SCK_I2C1SDA} />
      <trace from={U1.GND1} to="net.GND" />
      <trace from={U1.GND2} to="net.GND" />
      <trace from={U1.GND3} to="net.GND" />
      <trace from={U1.GND4} to="net.GND" />
      <trace from={U1.GND5} to="net.GND" />
      <trace from={U1.GND6} to="net.GND" />
      <trace from={U1.GND7} to="net.GND" />

      <trace from={U1.VBUS} to="net.V5" />

      <LedWithIc name="LED16" schX={8} />
      <trace from={".LED16 .GND"} to="net.GND" />
      <trace from={".LED16 .VDD"} to={"net.V5"} />
      <trace from=".LED16 .DI" to={U1.GP10_SPI1SCK_I2C1SDA} />
    </board>
  )
}
`} />


## Introduction

In this tutorial, we'll build a circuit consisting of:
- A 3x5 matrix of LEDs
- A Raspberry Pi Pico microcontroller
- An additional standalone LED

The final circuit will have the LEDs arranged in a grid pattern, with data being chained through each LED, and a separate LED controlled by a different GPIO pin. This setup is perfect for creating custom lighting displays, indicators, or interactive projects.


## Implementing the Grid System

To create our matrix layout, we use a grid helper function that calculates positions for each LED. Here's how we implement it:

:::note
This helper method can be imported from the [`math-utils`](https://github.com/tscircuit/math-utils) library
:::

```ts
function grid({
  rows,
  cols,
  xSpacing,
  ySpacing,
  width,
  height,
  offsetX = 0,
  offsetY = 0,
  yDirection = "cartesian",
}: GridOptions): GridCellPositions[] {
  // Calculate cell dimensions
  const cellWidth = width ? width / cols : xSpacing ?? 1
  const cellHeight = height ? height / rows : ySpacing ?? 1

  const cells: GridCellPositions[] = []

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const index = row * cols + col

      // Calculate center position
      const centerX = offsetX + col * cellWidth + cellWidth / 2
      const rawCenterY = offsetY + row * cellHeight + cellHeight / 2

      // Adjust Y coordinate based on yDirection
      const centerY =
        yDirection === "cartesian"
          ? offsetY + (rows - 1 - row) * cellHeight + cellHeight / 2
          : rawCenterY

      cells.push({
        index,
        center: { x: centerX, y: centerY },
        topLeft: {
          x: centerX - cellWidth / 2,
          y: centerY + cellHeight / 2,
        },
        bottomRight: {
          x: centerX + cellWidth / 2,
          y: centerY - cellHeight / 2,
        },
      })
    }
  }

  return cells
}
```

This grid function handles:

- Flexible grid dimensions (rows × columns)
- Customizable spacing between components
- Offset positioning for the entire grid
- Different coordinate system orientations

## Component Placement and Connections

### Placing the Pico
We can import the Pico microcontroller by following the steps as mentioned in the [Importing from jlcpcb](/guides/importing-modules-and-chips/importing-from-jlcpcb) section.
The height of the board taken is the maximum height of the component (for optimise the dimensions of PCB), which is the heigh to the pico `52mm`
The Pico is rotated `90deg` and pushed to one side of the board for optimal access to the pins.


```tsx
<board
      width="55mm"
      height="52mm"
      autorouter="auto-cloud" // Using autotrouter cloud
    >
      <U1 pcbRotation="90deg" pcbX={-15} pcbY={0} />
</board>
```

### Placing LEDs and Creating Traces

For each position in our grid, we need to:

- Place an LED
- Connect it to power and ground
- Chain the data lines between LEDs

Here's how we implement this:

```tsx
{grid({ cols: 3, rows: 5, xSpacing: 8, ySpacing: 5, offsetX: 3 }).map(
  ({ center, index }) => {
    const ledName = `LED${index + 1}`
    const prevLedName = index > 0 ? `LED${index}` : null
    return (
      <>
        <LedWithIc 
          schX={center.x/2} 
          schY={5 + center.y/2} 
          name={ledName} 
          pcbX={center.x} 
          pcbY={center.y} 
        />
        <trace from={`.${ledName} .GND`} to="net.GND" />
        <trace from={`.${ledName} .VDD`} to="net.V5" />
        {prevLedName && <trace from={`.${prevLedName} .DO`} to={`.${ledName} .DI`} />}
      </>
    )
  }
)}
```

Let's break down what's happening:

1. LED Placement

```tsx
<LedWithIc 
  schX={center.x/2} 
  schY={5 + center.y/2} 
  name={ledName} 
  pcbX={center.x} 
  pcbY={center.y} 
/>
```

- Each LED is positioned using the grid's calculated center points
- `schX` and `schY` define the schematic view position (scaled for better visibility)
- `pcbX` and `pcbY` define the actual PCB position
- Each LED gets a unique name (LED1, LED2, etc.)


2. Power Connections
```tsx
<trace from={`.${ledName} .GND`} to="net.GND" />
<trace from={`.${ledName} .VDD`} to="net.V5" />
```

- Every LED needs power (VDD) and ground connections
- We use the `.` syntax to reference specific pins on components
- `net.GND` and `net.V5` are global power nets


3. Data Chaining
```tsx
{prevLedName && <trace from={`.${prevLedName} .DO`} to={`.${ledName} .DI`} />}
```

- Creates a data chain by connecting each LED's data output (DO) to the next LED's data input (DI)
- The condition `prevLedName && ...` ensures we don't try to create a connection for the first LED

### Connecting to the Microcontroller
The first and last connections need special handling:
```tsx
// Connect the first LED's data input to the Pico
<trace from=".LED1 .DI" to={U1.GP6_SPI0SCK_I2C1SDA} />

// Connect the Pico's power pins
<trace from={U1.VBUS} to="net.V5" />

// Connect all Pico ground pins
<trace from={U1.GND1} to="net.GND" />
<trace from={U1.GND2} to="net.GND" />
<trace from={U1.GND3} to="net.GND" />
<trace from={U1.GND4} to="net.GND" />
<trace from={U1.GND5} to="net.GND" />
<trace from={U1.GND6} to="net.GND" />
<trace from={U1.GND7} to="net.GND" />
```

This completes our 3×5 LED matrix circuit with:

- All LEDs properly positioned in a grid
- Power and ground connections for each component
- Data signals chained through all LEDs
- Proper connections to the Pico microcontroller

Checkout this circuit in our [Playground](https://tscircuit.com/editor?snippet_id=1a50442c-d352-4cf8-ae2d-bfc442cff0aa).